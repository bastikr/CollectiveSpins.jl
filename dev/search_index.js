var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-System","page":"API","title":"System","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spin","category":"page"},{"location":"api/#CollectiveSpins.system.Spin","page":"API","title":"CollectiveSpins.system.Spin","text":"A class representing a single spin.\n\nA spin is defined by its position and its detuning to a main frequency.\n\nArguments\n\nposition: A vector defining a point in R3.\ndelta: Detuning.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"SpinCollection","category":"page"},{"location":"api/#CollectiveSpins.system.SpinCollection","page":"API","title":"CollectiveSpins.system.SpinCollection","text":"A class representing a system consisting of many spins.\n\nArguments\n\nspins: Vector of spins.\npolarizations: Unit vectors defining the directions of the spins.\ngammas: Decay rates.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CavityMode","category":"page"},{"location":"api/#CollectiveSpins.system.CavityMode","page":"API","title":"CollectiveSpins.system.CavityMode","text":"A class representing a single mode in a cavity.\n\nArguments\n\ncutoff: Number of included Fock states.\ndelta=0 Detuning.\neta=0: Pump strength.\nkappa=0: Decay rate.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CavitySpinCollection","category":"page"},{"location":"api/#CollectiveSpins.system.CavitySpinCollection","page":"API","title":"CollectiveSpins.system.CavitySpinCollection","text":"A class representing a cavity coupled to many spins.\n\nArguments\n\ncavity: A CavityMode.\nspincollection: A SpinCollection.\ng: A vector defing the coupling strengths between the i-th spin and   the cavity mode. Alternatively a single number can be given for   identical coupling for all spins.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Geometry","page":"API","title":"Geometry","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"geometry.chain","category":"page"},{"location":"api/#CollectiveSpins.geometry.chain","page":"API","title":"CollectiveSpins.geometry.chain","text":"geometry.chain(a, N)\n\nPositions of spins on a chain in x-direction.\n\nThe chain starts at the origin and continues into positive x-direction.\n\nArguments\n\na: Spin-spin distance.\nN: Number of spins\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.triangle","category":"page"},{"location":"api/#CollectiveSpins.geometry.triangle","page":"API","title":"CollectiveSpins.geometry.triangle","text":"geometry.triangle(a)\n\nPositions of spins on a equilateral triangle in the xy-plane with edge length a.\n\nThe positions are: (0,0,0), (a,0,0), (a/2, h, 0)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.rectangle","category":"page"},{"location":"api/#CollectiveSpins.geometry.rectangle","page":"API","title":"CollectiveSpins.geometry.rectangle","text":"geometry.rectangle(a, b; Nx=2, Ny=2)\n\nPositions of spins on a rectangular lattice in the xy-plane.\n\nThe lattice starts at the origin and continues into positive x and y direction.\n\nArguments\n\na: Spin-spin distance in x-direction.\nb: Spin-spin distance in y-direction.\nNx=2: Number of spins into x direction.\nNy=2: Number of spins into y direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.square","category":"page"},{"location":"api/#CollectiveSpins.geometry.square","page":"API","title":"CollectiveSpins.geometry.square","text":"geometry.square(a; Nx=2, Ny=2)\n\nPositions of spins on a square lattice in the xy-plane with distance a.\n\nThe lattice starts at the origin and continues into positive x and y direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.hexagonal","category":"page"},{"location":"api/#CollectiveSpins.geometry.hexagonal","page":"API","title":"CollectiveSpins.geometry.hexagonal","text":"geometry.hexagonal(a; Nr=1)\n\nPositions of spins on a hexagonal lattice in the xy-plane.\n\nThe hexagonal lattice consists of Nr rings.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.box","category":"page"},{"location":"api/#CollectiveSpins.geometry.box","page":"API","title":"CollectiveSpins.geometry.box","text":"geometry.box(a, b, c; Nx=2, Ny=2, Nz=2)\n\nPositions of spins on a orthorhombic lattice.\n\nThe lattice starts at the origin and continues into positive x, y and z direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.cube","category":"page"},{"location":"api/#CollectiveSpins.geometry.cube","page":"API","title":"CollectiveSpins.geometry.cube","text":"geometry.cube(a; Nx=2, Ny=2, Nz=2)\n\nPositions of spins on a cubic lattice with edge length a.\n\nThe lattice starts at the origin and continues into positive x, y and z direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Dipole-Dipole-Interaction","page":"API","title":"Dipole-Dipole Interaction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.Omega","category":"page"},{"location":"api/#CollectiveSpins.interaction.Omega","page":"API","title":"CollectiveSpins.interaction.Omega","text":"interaction.Omega(ri::Vector, rj::Vector, µi::Vector, µj::Vector, γi::Real=1, γj::Real=1)\n\nArguments:\n\nri: Position of first spin\nrj: Position of second spin\nµi: Dipole orientation of first spin.\nµj: Dipole orientation of second spin.\nγi: Decay rate of first spin.\nγj: Decay rate of second spin.\n\nNote that the dipole moments μi and μj are normalized internally. To account for dipole moments with different lengths you need to scale the decay rates γi and γj, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.Gamma","category":"page"},{"location":"api/#CollectiveSpins.interaction.Gamma","page":"API","title":"CollectiveSpins.interaction.Gamma","text":"interaction.Gamma(ri::Vector, rj::Vector, µi::Vector, µj::Vector, γi::Real=1, γj::Real=1)\n\nArguments:\n\nri: Position of first spin\nrj: Position of second spin\nµi: Dipole orientation of first spin.\nµj: Dipole orientation of second spin.\nγi: Decay rate of first spin.\nγj: Decay rate of second spin.\n\nNote that the dipole moments μi and μj are normalized internally. To account for dipole moments with different lengths you need to scale the decay rates γi and γj, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.GammaMatrix","category":"page"},{"location":"api/#CollectiveSpins.interaction.GammaMatrix","page":"API","title":"CollectiveSpins.interaction.GammaMatrix","text":"interaction.GammaMatrix(S::SpinCollection)\n\nMatrix of the collective decay rate for a given SpinCollection.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.OmegaMatrix","category":"page"},{"location":"api/#CollectiveSpins.interaction.OmegaMatrix","page":"API","title":"CollectiveSpins.interaction.OmegaMatrix","text":"interaction.OmegaMatrix(S::SpinCollection)\n\nMatrix of the dipole-dipole interaction for a given SpinCollection.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.GreenTensor","category":"page"},{"location":"api/#CollectiveSpins.interaction.GreenTensor","page":"API","title":"CollectiveSpins.interaction.GreenTensor","text":"GreenTensor(r::Vector, k::Number=2π)\n\nCalculate the Green's Tensor at position r for wave number k defined by\n\nG = e^ikrBigleft(frac1kr + fraci(kr)^2 - frac1(kr)^3right)*I -\n    textbfrtextbrfr^Tleft(frac1kr + frac3i(kr)^2 - frac3(kr)^3right)Big\n\nChoosing k=2π corresponds to the position r being given in units of the wavelength associated with the dipole transition.\n\nReturns a 3×3 complex Matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.Omega_ij","category":"page"},{"location":"api/#CollectiveSpins.interaction.Omega_ij","page":"API","title":"CollectiveSpins.interaction.Omega_ij","text":"Omega_ij(r1::Vector,r2::Vector,μ1::Vector,μ2::Vector;gamma1=1,gamma2=1,k0=2π)\n\nFrom the field overlap with the Green's tensor, compute the energy shifts as\n\nΩ_ij = -frac34 μᵢ*  ℜ(G)  μⱼ\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.Gamma_ij","category":"page"},{"location":"api/#CollectiveSpins.interaction.Gamma_ij","page":"API","title":"CollectiveSpins.interaction.Gamma_ij","text":"Gamma_ij(r1::Vector,r2::Vector,μ1::Vector,μ2::Vector;gamma1=1,gamma2=1,k0=2π)\n\nFrom the field overlap with the Green's tensor, compute the mutual decay rate as\n\nΓ_ij = frac32 μᵢ*  ℑ(G)  μⱼ\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.G_ij","category":"page"},{"location":"api/#API:-Effective-Interactions","page":"API","title":"Effective Interactions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.triangle_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.triangle_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.triangle_orthogonal","text":"effective_interaction.triangle_orthogonal(a)\n\nEffective Omega and Gamma for a equilateral triangle with edge length a.\n\nThe polarization axis is orthogonal to the triangle plane.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.square_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.square_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.square_orthogonal","text":"effective_interaction.square_orthogonal(a)\n\nEffective Omega and Gamma for a square with edge length a.\n\nThe polarization axis is orthogonal to the square plane.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.rectangle_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.rectangle_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.rectangle_orthogonal","text":"effective_interaction.rectangle_orthogonal(a, b)\n\nEffective Omega and Gamma for a rectangle with edge lengths a and b.\n\nThe polarization axis is orthogonal to the rectangle plane.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.cube_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.cube_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.cube_orthogonal","text":"effective_interaction.cube_orthogonal(a)\n\nEffective Omega and Gamma for a cube with edge length a\n\nThe polarization axis is orthogonal to the xy faces.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.box_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.box_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.box_orthogonal","text":"effective_interaction.box_orthogonal(a, b, c)\n\nEffective Omega and Gamma for a box with edge lengths a, b and c.\n\nThe polarization axis is orthogonal to the top face.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.chain","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.chain","page":"API","title":"CollectiveSpins.effective_interaction.chain","text":"effective_interaction.chain(a, Θ, N)\n\nEffective Omega and Gamma for an infinite chain.\n\nThe calculation is done by adding N spins left and N spins right of a central spin.\n\nArguments\n\na: Spin-spin distance.\nθ: Angle between polarization axis and spin chain.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.chain_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.chain_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.chain_orthogonal","text":"effective_interaction.chain_orthogonal(a, N)\n\nEffective Omega and Gamma for an infinite chain with orthogonal polarization axis.\n\nThe calculation is done by adding N spins left and N spins right of a central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.squarelattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.squarelattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.squarelattice_orthogonal","text":"effective_interaction.squarelattice_orthogonal(a, N)\n\nEffective Omega and Gamma for a infinite square lattice.\n\nThe polarization axis is orthogonal to the square lattice plane and the calculation is done by creating a (2N+1)*(2N+1) square lattice and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.hexagonallattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.hexagonallattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.hexagonallattice_orthogonal","text":"effective_interaction.hexagonallattice_orthogonal(a, N)\n\nEffective Omega and Gamma for a infinite hexagonal lattice.\n\nThe polarization axis is orthogonal to the square lattice plane and the calculation is done by creating hexagonal lattice consisting of N rings and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.cubiclattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.cubiclattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.cubiclattice_orthogonal","text":"effective_interaction.cubiclattice_orthogonal(a, N)\n\nEffective Omega and Gamma for a infinite cubic lattice.\n\nThe polarization axis is orthogonal to the top face of a unit cell and the calculation is done by creating a (2N+1)(2N+1)(2N+1) cubic lattice and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.tetragonallattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.tetragonallattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.tetragonallattice_orthogonal","text":"effective_interaction.tetragonallattice_orthogonal(a, b, N)\n\nEffective Omega and Gamma for a infinite tetragonal lattice.\n\nThe polarization axis is orthogonal to the top face of a unit cell and the calculation is done by creating a (2N+1)(2N+1)(2N+1) tetragonal lattice and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance for bottom side square.\nb: Height of the unit cell.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","text":"effective_interaction.hexagonallattice3d_orthogonal(a, b, N)\n\nEffective Omega and Gamma for a infinite 3D hexagonal lattice.\n\nThe lattice consists of stacked planes of hexagonal lattices where the the polarization axis is orthogonal to the planes. The calculation is done by creating hexagonal lattices with N rings, stacking 2N+1 lattices of this kind above each other and calculating the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance for hexagons.\nb: Distance between planes of hexagonal lattices\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Rotetated-effective-interactions","page":"API","title":"Rotated effective interactions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction_rotated.square_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction_rotated.square_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction_rotated.square_orthogonal","text":"effective_interaction_rotated.square_orthogonal(a, Nδ)\n\nEffective Omega and Gamma for a square.\n\nThe polarization axis is orthogonal to the square plane.\n\nArguments\n\na: Edge length.\nNδ: Phase shift (Number of atoms in 2π).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction_rotated.cube_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction_rotated.cube_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction_rotated.cube_orthogonal","text":"effective_interaction_rotated.cube_orthogonal(a, dϕ)\n\nEffective Omega and Gamma for a cube.\n\nThe polarization axis is orthogonal to the xy faces.\n\nArguments\n\na: edge length.\ndϕ: Phase shift.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction_rotated.chain_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction_rotated.chain_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction_rotated.chain_orthogonal","text":"effective_interaction_rotated.chain_orthogonal(a, N, dϕ)\n\nEffective Omega and Gamma for an infinite chain.\n\nThe polarization axis is orthogonal to the chain and the calculation is done by adding N spins left and N spins right of a central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\ndϕ: Phase shift between neighboring spins.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#API:-Methods-quantum","page":"API","title":"Quantum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.basis","category":"page"},{"location":"api/#CollectiveSpins.quantum.basis","page":"API","title":"CollectiveSpins.quantum.basis","text":"quantum.basis(x)\n\nGet basis of the given System.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.blochstate","category":"page"},{"location":"api/#CollectiveSpins.quantum.blochstate","page":"API","title":"CollectiveSpins.quantum.blochstate","text":"quantum.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.dim","category":"page"},{"location":"api/#CollectiveSpins.quantum.dim","page":"API","title":"CollectiveSpins.quantum.dim","text":"quantum.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.Hamiltonian","category":"page"},{"location":"api/#CollectiveSpins.quantum.Hamiltonian","page":"API","title":"CollectiveSpins.quantum.Hamiltonian","text":"quantum.Hamiltonian(S)\n\nHamiltonian of the given System.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.JumpOperators","category":"page"},{"location":"api/#CollectiveSpins.quantum.JumpOperators","page":"API","title":"CollectiveSpins.quantum.JumpOperators","text":"quantum.JumpOperators(S)\n\nJump operators of the given system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.JumpOperators_diagonal","category":"page"},{"location":"api/#CollectiveSpins.quantum.JumpOperators_diagonal","page":"API","title":"CollectiveSpins.quantum.JumpOperators_diagonal","text":"quantum.JumpOperators_diagonal(S)\n\nJump operators of the given system. (diagonalized)\n\nDiagonalized means that the Gamma matrix is diagonalized and the jump operators are changed accordingly.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.timeevolution_diagonal","category":"page"},{"location":"api/#CollectiveSpins.quantum.timeevolution_diagonal","page":"API","title":"CollectiveSpins.quantum.timeevolution_diagonal","text":"quantum.timeevolution_diagonal(T, S, state0[; fout])\n\nMaster equation time evolution. (diagonalized)\n\nDiagonalized means that the Gamma matrix is diagonalized and the jump operators are changed accordingly.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: System\nρ₀: Initial density operator.\nfout (optional): Function with signature fout(t, state) that is called   whenever output should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.quantum.timeevolution","page":"API","title":"CollectiveSpins.quantum.timeevolution","text":"quantum.timeevolution(T, S, state0[; fout])\n\nMaster equation time evolution.\n\nDiagonalized means that the Gamma matrix is diagonalized and the jump operators are changed accordingly.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: System\nρ₀: Initial density operator.\nfout (optional): Function with signature fout(t, state) that is called   whenever output should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.rotate","category":"page"},{"location":"api/#CollectiveSpins.quantum.rotate","page":"API","title":"CollectiveSpins.quantum.rotate","text":"meanfield.rotate(axis, angles, state)\n\nRotations on the Bloch sphere for the given density operator.\n\nArguments\n\naxis: Rotation axis.\nangles: Rotation angle(s).\nρ: Density operator that should be rotated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.squeeze","category":"page"},{"location":"api/#CollectiveSpins.quantum.squeeze","page":"API","title":"CollectiveSpins.quantum.squeeze","text":"quantum.squeeze(axis, χT, ρ₀)\n\nSpin squeezing along an arbitrary axis.\n\nArguments\n\naxis: Squeezing axis.\nχT: Squeezing strength.\nρ₀: Operator that should be squeezed.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.squeezingparameter","category":"page"},{"location":"api/#CollectiveSpins.quantum.squeezingparameter","page":"API","title":"CollectiveSpins.quantum.squeezingparameter","text":"quantum.squeezingparameter(ρ)\n\nCalculate squeezing parameter for the given state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-cumulant0","page":"API","title":"0th order: Independent spins","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.blochstate","category":"page"},{"location":"api/#CollectiveSpins.independent.blochstate","page":"API","title":"CollectiveSpins.independent.blochstate","text":"independent.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.dim","category":"page"},{"location":"api/#CollectiveSpins.independent.dim","page":"API","title":"CollectiveSpins.independent.dim","text":"independent.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.splitstate","category":"page"},{"location":"api/#CollectiveSpins.independent.splitstate","page":"API","title":"CollectiveSpins.independent.splitstate","text":"independent.splitstate(state)\n\nSplit state into sx, sy and sz parts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.densityoperator","category":"page"},{"location":"api/#CollectiveSpins.independent.densityoperator","page":"API","title":"CollectiveSpins.independent.densityoperator","text":"independent.densityoperator(sx, sy, sz)\nindependent.densityoperator(state)\n\nCreate density operator from independent sigma expectation values.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.sx","category":"page"},{"location":"api/#CollectiveSpins.independent.sx","page":"API","title":"CollectiveSpins.independent.sx","text":"independent.sx(state)\n\nSigma x expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.sy","category":"page"},{"location":"api/#CollectiveSpins.independent.sy","page":"API","title":"CollectiveSpins.independent.sy","text":"independent.sy(state)\n\nSigma y expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.sz","category":"page"},{"location":"api/#CollectiveSpins.independent.sz","page":"API","title":"CollectiveSpins.independent.sz","text":"independent.sz(state)\n\nSigma z expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.independent.timeevolution","page":"API","title":"CollectiveSpins.independent.timeevolution","text":"independent.timeevolution(T, gamma, state0)\n\nIndependent time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\ngamma: Single spin decay rate.\nstate0: Initial state.\n\n\n\n\n\nindependent.timeevolution(T, S::SpinCollection, state0)\n\nIndependent time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: SpinCollection describing the system.\nstate0: Initial state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-cumulant1","page":"API","title":"1st order: Meanfield","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.ProductState","category":"page"},{"location":"api/#CollectiveSpins.meanfield.ProductState","page":"API","title":"CollectiveSpins.meanfield.ProductState","text":"Class describing a Meanfield state (Product state).\n\nThe data layout is [sx1 sx2 ... sy1 sy2 ... sz1 sz2 ...]\n\nArguments\n\nN: Number of spins.\ndata: Vector of length 3*N.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.blochstate","category":"page"},{"location":"api/#CollectiveSpins.meanfield.blochstate","page":"API","title":"CollectiveSpins.meanfield.blochstate","text":"meanfield.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.dim","category":"page"},{"location":"api/#CollectiveSpins.meanfield.dim","page":"API","title":"CollectiveSpins.meanfield.dim","text":"meanfield.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.splitstate","category":"page"},{"location":"api/#CollectiveSpins.meanfield.splitstate","page":"API","title":"CollectiveSpins.meanfield.splitstate","text":"meanfield.splitstate(N, data)\nmeanfield.splitstate(state)\n\nSplit state into sx, sy and sz parts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.densityoperator","category":"page"},{"location":"api/#CollectiveSpins.meanfield.densityoperator","page":"API","title":"CollectiveSpins.meanfield.densityoperator","text":"mpc.densityoperator(state)\n\nCreate density operator from MPCState.\n\n\n\n\n\nmeanfield.densityoperator(sx, sy, sz)\nmeanfield.densityoperator(state)\n\nCreate density operator from independent sigma expectation values.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.sx","category":"page"},{"location":"api/#CollectiveSpins.meanfield.sx","page":"API","title":"CollectiveSpins.meanfield.sx","text":"meanfield.sx(state)\n\nSigma x expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.sy","category":"page"},{"location":"api/#CollectiveSpins.meanfield.sy","page":"API","title":"CollectiveSpins.meanfield.sy","text":"meanfield.sy(state)\n\nSigma y expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.sz","category":"page"},{"location":"api/#CollectiveSpins.meanfield.sz","page":"API","title":"CollectiveSpins.meanfield.sz","text":"meanfield.sz(state)\n\nSigma z expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.meanfield.timeevolution","page":"API","title":"CollectiveSpins.meanfield.timeevolution","text":"meanfield.timeevolution(T, S::SpinCollection, state0[; fout])\n\nMeanfield time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: SpinCollection describing the system.\nstate0: Initial ProductState.\nfout (optional): Function with signature fout(t, state) that is called whenever output   should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.timeevolution_symmetric","category":"page"},{"location":"api/#CollectiveSpins.meanfield.timeevolution_symmetric","page":"API","title":"CollectiveSpins.meanfield.timeevolution_symmetric","text":"meanfield.timeevolution_symmetric(T, state0, Ωeff, Γeff[; γ, δ0, fout])\n\nSymmetric meanfield time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nstate0: Initial ProductState.\nΩeff: Effective dipole-dipole interaction.\nΓeff: Effective collective decay rate.\nγ=1: Single spin decay rate.\nδ0=0: Phase shift for rotated symmetric meanfield time evolution.\nfout (optional): Function with signature fout(t, state) that is called whenever output   should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.rotate","category":"page"},{"location":"api/#CollectiveSpins.meanfield.rotate","page":"API","title":"CollectiveSpins.meanfield.rotate","text":"meanfield.rotate(axis, angles, state)\n\nRotations on the Bloch sphere for the given ProductState.\n\nArguments\n\naxis: Rotation axis.\nangles: Rotation angle(s).\nstate: ProductState that should be rotated.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-cumulant2","page":"API","title":"2nd order: Meanfield plus Correlations (MPC)","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.MPCState","category":"page"},{"location":"api/#CollectiveSpins.mpc.MPCState","page":"API","title":"CollectiveSpins.mpc.MPCState","text":"Class describing a MPC state (Product state + Correlations).\n\nThe data layout is vector that in matrix form looks like\n\nCxx Cxy Cyy Cxz Czz Cyz\n\nwhere the Cij are the appropriate correlation matrices. The expectation values sx, sy and sz are the diagonals of the matrices Cxx, Cyy and Czz, respectively.\n\nArguments\n\nN: Number of spins.\ndata: Vector of length (3N)(2*N+1).\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.blochstate","category":"page"},{"location":"api/#CollectiveSpins.mpc.blochstate","page":"API","title":"CollectiveSpins.mpc.blochstate","text":"mpc.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.dim","category":"page"},{"location":"api/#CollectiveSpins.mpc.dim","page":"API","title":"CollectiveSpins.mpc.dim","text":"mpc.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.splitstate","category":"page"},{"location":"api/#CollectiveSpins.mpc.splitstate","page":"API","title":"CollectiveSpins.mpc.splitstate","text":"mpc.splitstate(N, data)\nmpc.splitstate(state)\n\nReturns sx, sy, sz, Cxx, Cyy, Czz, Cxy, Cxz, Cyz.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.correlation2covariance","category":"page"},{"location":"api/#CollectiveSpins.mpc.correlation2covariance","page":"API","title":"CollectiveSpins.mpc.correlation2covariance","text":"mpc.correlation2covariance(corstate)\n\nConvert a MPCState from correlation form into covariance form.\n\nBasically it just calculates Covab = <sa sb> - <sa> <s_b>.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.covariance2correlation","category":"page"},{"location":"api/#CollectiveSpins.mpc.covariance2correlation","page":"API","title":"CollectiveSpins.mpc.covariance2correlation","text":"mpc.covariance2correlation(covstate)\n\nConvert a MPCState from covariance form into correlation form.\n\nBasically it just calculates <sa sb> = Covab + <sa> <s_b>.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.densityoperator(::CollectiveSpins.MPCState)","category":"page"},{"location":"api/#CollectiveSpins.meanfield.densityoperator-Tuple{CollectiveSpins.mpc.MPCState}","page":"API","title":"CollectiveSpins.meanfield.densityoperator","text":"mpc.densityoperator(state)\n\nCreate density operator from MPCState.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.sx","category":"page"},{"location":"api/#CollectiveSpins.mpc.sx","page":"API","title":"CollectiveSpins.mpc.sx","text":"mpc.sx(state)\n\nSigma x expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.sy","category":"page"},{"location":"api/#CollectiveSpins.mpc.sy","page":"API","title":"CollectiveSpins.mpc.sy","text":"mpc.sy(state)\n\nSigma y expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.sz","category":"page"},{"location":"api/#CollectiveSpins.mpc.sz","page":"API","title":"CollectiveSpins.mpc.sz","text":"mpc.sz(state)\n\nSigma z expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cxx","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cxx","page":"API","title":"CollectiveSpins.mpc.Cxx","text":"mpc.Cxx(state)\n\nSigmax-Sigmax correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cyy","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cyy","page":"API","title":"CollectiveSpins.mpc.Cyy","text":"mpc.Cyy(state)\n\nSigmay-Sigmay correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Czz","category":"page"},{"location":"api/#CollectiveSpins.mpc.Czz","page":"API","title":"CollectiveSpins.mpc.Czz","text":"mpc.Czz(state)\n\nSigmaz-Sigmaz correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cxy","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cxy","page":"API","title":"CollectiveSpins.mpc.Cxy","text":"mpc.Cxy(state)\n\nSigmax-Sigmay correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cxz","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cxz","page":"API","title":"CollectiveSpins.mpc.Cxz","text":"mpc.Cxz(state)\n\nSigmax-Sigmaz correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cyz","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cyz","page":"API","title":"CollectiveSpins.mpc.Cyz","text":"mpc.Cyz(state)\n\nSigmay-Sigmaz correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.mpc.timeevolution","page":"API","title":"CollectiveSpins.mpc.timeevolution","text":"mpc.timeevolution(T, S::SpinCollection, state0[; fout])\n\nMPC time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: SpinCollection describing the system.\nstate0: Initial MPCState.\nfout (optional): Function with signature fout(t, state) that is called   whenever output should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.rotate","category":"page"},{"location":"api/#CollectiveSpins.mpc.rotate","page":"API","title":"CollectiveSpins.mpc.rotate","text":"mpc.rotate(axis, angles, state)\n\nRotations on the Bloch sphere for the given MPCState.\n\nArguments\n\naxis: Rotation axis.\nangles: Rotation angle(s).\nstate: MPCState that should be rotated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.var_Sx","category":"page"},{"location":"api/#CollectiveSpins.mpc.var_Sx","page":"API","title":"CollectiveSpins.mpc.var_Sx","text":"mpc.var_Sx(state0)\n\nVariance of the total Sx operator for the given MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.var_Sy","category":"page"},{"location":"api/#CollectiveSpins.mpc.var_Sy","page":"API","title":"CollectiveSpins.mpc.var_Sy","text":"mpc.var_Sy(state)\n\nVariance of the total Sy operator for the given MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.var_Sz","category":"page"},{"location":"api/#CollectiveSpins.mpc.var_Sz","page":"API","title":"CollectiveSpins.mpc.var_Sz","text":"mpc.var_Sz(state)\n\nVariance of the total Sz operator for the given MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.squeeze","category":"page"},{"location":"api/#CollectiveSpins.mpc.squeeze","page":"API","title":"CollectiveSpins.mpc.squeeze","text":"mpc.squeeze(axis, χT, state0)\n\nSpin squeezing along an arbitrary axis.\n\nArguments\n\naxis: Squeezing axis.\nχT: Squeezing strength.\nstate0: MPCState that should be squeezed.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.squeezingparameter","category":"page"},{"location":"api/#CollectiveSpins.mpc.squeezingparameter","page":"API","title":"CollectiveSpins.mpc.squeezingparameter","text":"mpc.squeezing_parameter(state)\n\nCalculate squeezing parameter for the given state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-reduced","page":"API","title":"Reduced Spin","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.reducedsigmap","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmap","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmap","text":"reducedsigmap(b::ReducedSpinBasis, j::Int)\n\nSigma Plus Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.reducedspintransition","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedspintransition","page":"API","title":"CollectiveSpins.reducedspin.reducedspintransition","text":"reducedspintransition(b::ReducedSpinBasis, to::Vector{Int}, from::Vector{Int})\n\nTransition operator mathrmtomathrmfrom, where to and from are given as vectors denoting the excitations.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.ReducedSpinBasis","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.ReducedSpinBasis","page":"API","title":"CollectiveSpins.reducedspin.ReducedSpinBasis","text":"ReducedSpinBasis(N, M)\n\nBasis for a system of N spin 1/2 systems, up to the M'th excitation.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.reducedsigmam","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmam","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmam","text":"reducedsigmam(b::ReducedSpinBasis, j::Int)\n\nSigma Minus Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.reducedsigmaz","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmaz","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmaz","text":"reducedsigmaz(b::ReducedSpinBasis, j::Int)\n\nSigma-Z Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.reducedspinstate","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedspinstate","page":"API","title":"CollectiveSpins.reducedspin.reducedspinstate","text":"reducedspinstate(b::ReducedSpinBasis, inds::Vector{Int})\n\nState where the excitations are placed in the atoms given by inds. Note, that b.MS <= length(inds) <= b.M must be satisfied.\n\nExamples\n\njulia> b = CollectiveSpins.ReducedSpinBasis(4,2)\nReducedSpin(N=4, M=2, MS=0)\n\njulia> GS = CollectiveSpins.reducedspinstate(b,[]) # get the ground state\nKet(dim=11)\n  basis: ReducedSpin(N=4, M=2, MS=0)\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> ψ2 = CollectiveSpins.reducedspinstate(b,[1,2]) # First and second atom excited\nKet(dim=11)\n  basis: ReducedSpin(N=4, M=2, MS=0)\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.reducedsigmay","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmay","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmay","text":"reducedsigmay(b::ReducedSpinBasis, j::Int)\n\nSigma-Y Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.reducedspin.reducedsigmax","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmax","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmax","text":"reducedsigmax(b::ReducedSpinBasis, j::Int)\n\nSigma-X Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"In order to simplify creation of various particle distributions, a few helper functions with self-explanatory names are provided:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry.chain\ngeometry.triangle\ngeometry.rectangle\ngeometry.square\ngeometry.hexagonal\ngeometry.box\ngeometry.cube","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"They can be used directly to create a SpinCollection:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"SpinCollection(geometry.chain(0.5, 6), [0,0,1])","category":"page"},{"location":"system/#System","page":"System","title":"System","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"The basic building blocks used in CollectiveSpins.jl are, not surprisingly, spins. They are defined by their position and a frequency Delta describing a shift relative to the frequency of the rotating frame in use:","category":"page"},{"location":"system/","page":"System","title":"System","text":"mutable struct Spin <: System\n    position::Vector{Float64}\n    delta::Float64\nend","category":"page"},{"location":"system/","page":"System","title":"System","text":"Defining the frequency is optional and is set to zero by default:","category":"page"},{"location":"system/","page":"System","title":"System","text":"Spin([0,0,0]; delta=1)\nSpin([0,0,0])","category":"page"},{"location":"system/","page":"System","title":"System","text":"Combining many spins into one big system can be done by using the SpinCollection type. All contained spins must have the same polarization axis and decay rate gamma:","category":"page"},{"location":"system/","page":"System","title":"System","text":"mutable struct SpinCollection <: System\n    spins::Vector{Spin}\n    polarization::Vector{Float64}\n    gamma::Float64\nend","category":"page"},{"location":"system/","page":"System","title":"System","text":"For convenience one can create a SpinCollection without explicitly constructing the single spins first::","category":"page"},{"location":"system/","page":"System","title":"System","text":"SpinCollection([[0,0,0], [1,0,0]], [0,0,1]; gamma=2, delta=1)","category":"page"},{"location":"system/","page":"System","title":"System","text":"Adding a cavity can be done with the CavityMode type:","category":"page"},{"location":"system/","page":"System","title":"System","text":"mutable struct CavityMode <: System\n    cutoff::Int\n    delta::Float64\n    eta::Float64\n    kappa::Float64\nend","category":"page"},{"location":"system/","page":"System","title":"System","text":"which can be coupled to a spin collection with coupling strength g via the CavitySpinCollection type:","category":"page"},{"location":"system/","page":"System","title":"System","text":"mutable struct CavitySpinCollection <: System\n    cavity::CavityMode\n    spincollection::SpinCollection\n    g::Vector{Float64}\nend","category":"page"},{"location":"interaction/#Dipole-Dipole-interaction","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"","category":"section"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"Of course the core of this library are the equations describing the dipole-dipole interaction and the collective decay","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"beginaligned\nGamma_ij = frac32 sqrtGamma_i Gamma_j F_ij(k_a r_ij) \nOmega_ij = frac34 sqrtGamma_i Gamma_j G_ij(k_a r_ij)\nendaligned","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"with","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"beginaligned\nF_ij(xi) =\n            big( 1 - (vece^(r)  vece^(d_eg))^2 big) fracsin xixi\n            + big( 1 - 3 (vece^(r)  vece^(d_eg))^2 big)\n                big( fraccos xixi^2 - fracsin xixi^3big)\n\nG_ij(xi) =\n             - big(1 - (vece^(r)  vece^(d_eg))^2 big) fraccos xixi\n            + big( 1 - 3 (vece^(r)  vece^(d_eg))^2 big)\n                big( fracsin xixi^2 - fraccos xixi^3big)\nendaligned","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"They are implemented in the functions:","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"CollectiveSpins.interaction.Omega\nCollectiveSpins.interaction.Gamma","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"To create the interaction matrices the following two shortcuts are provided:","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"CollectiveSpins.interaction.GammaMatrix\nCollectiveSpins.interaction.OmegaMatrix","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest official release, you can use Julia's internal package manager. Simply start the Julia interpreter, press the ] key and type","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"\tpkg> add CollectiveSpins","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The source code is available on GitHub at https://github.com/qojulia/CollectiveSpins.jl (Note: this version may be unstable). You can also use Julia's package manager to checkout this version.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"\tpkg> develop CollectiveSpins","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Alternatively, you can use git to clone the repository.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"\t>> git clone https://github.com/qojulia/CollectiveSpins.jl.git","category":"page"},{"location":"descriptions/#Theoretical-Descriptions","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"CollectiveSpins.jl provides several different possibilities to simulate multi-spin systems. A full quantum description is available but only possible for small numbers of spins. Additionally, approximations of different orders are implemented using a cumulant expansion approach:","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"quantum - descriptions-quantum\nindependent - descriptions-cumulant0\nmeanfield - descriptions-cumulant1\nmpc - descriptions-cumulant2","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"All variants provide a unified interface wherever possible:","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"blochstate(phi, theta)\ndensityoperator(state)\nsx(state)\nsy(state)\nsz(state)\ntimeevolution(T, system, state0; fout=nothing)\nrotate(axis, angles, state)\nsqueeze(axis, χT, state)\nsqueezingparameter(state)","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"The following example should give a first idea how these implementations are used:","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"using QuantumOptics, CollectiveSpins\nconst cs = CollectiveSpins\n\n# System parameters\nconst a = 0.18\nconst γ = 1.\nconst e_dipole = [0,0,1.]\nconst T = [0:0.05:5;]\nconst N = 5\nconst Ncenter = 3\n\nconst system = SpinCollection(cs.geometry.chain(a, N), e_dipole; gamma=γ)\n\n\n# Define Spin 1/2 operators\nspinbasis = SpinBasis(1//2)\nsigmax = spin.sigmax(spinbasis)\nsigmay = spin.sigmay(spinbasis)\nsigmaz = spin.sigmaz(spinbasis)\nsigmap = spin.sigmap(spinbasis)\nsigmam = spin.sigmam(spinbasis)\nI_spin = identityoperator(spinbasis)\n\n# Initial state (Bloch state)\nconst phi = 0.\nconst theta = pi/2.\n\n# Time evolution\n\n# Independent\nstate0 = cs.independent.blochstate(phi, theta, N)\ntout, state_ind_t = cs.independent.timeevolution(T, system, state0)\n\n# Meanfield\nstate0 = cs.meanfield.blochstate(phi, theta, N)\ntout, state_mf_t = cs.meanfield.timeevolution(T, system, state0)\n\n# Meanfield + Correlations\nstate0 = cs.mpc.blochstate(phi, theta, N)\ntout, state_mpc_t = cs.mpc.timeevolution(T, system, state0)\n\n# Quantum: master equation\nsx_master = Float64[]\nsy_master = Float64[]\nsz_master = Float64[]\n\ntd_ind = Float64[]\ntd_mf  = Float64[]\ntd_mpc = Float64[]\n\nembed(op::Operator) = QuantumOptics.embed(cs.quantum.basis(system), Ncenter, op)\n\nfunction fout(t, rho::Operator)\n    i = findfirst(T, t)\n    rho_ind = cs.independent.densityoperator(state_ind_t[i])\n    rho_mf  = cs.meanfield.densityoperator(state_mf_t[i])\n    rho_mpc = cs.mpc.densityoperator(state_mpc_t[i])\n    push!(td_ind, tracedistance(rho, rho_ind))\n    push!(td_mf,  tracedistance(rho, rho_mf))\n    push!(td_mpc, tracedistance(rho, rho_mpc))\n    push!(sx_master, real(expect(embed(sigmax), rho)))\n    push!(sy_master, real(expect(embed(sigmay), rho)))\n    push!(sz_master, real(expect(embed(sigmaz), rho)))\nend\n\nΨ₀ = cs.quantum.blochstate(phi,theta,N)\nρ₀ = Ψ₀⊗dagger(Ψ₀)\ncs.quantum.timeevolution(T, system, ρ₀, fout=fout)\n\n# Expectation values\nmapexpect(op, states) = map(s->(op(s)[Ncenter]), states)\n\nsx_ind = mapexpect(cs.independent.sx, state_ind_t)\nsy_ind = mapexpect(cs.independent.sy, state_ind_t)\nsz_ind = mapexpect(cs.independent.sz, state_ind_t)\n\nsx_mf = mapexpect(cs.meanfield.sx, state_mf_t)\nsy_mf = mapexpect(cs.meanfield.sy, state_mf_t)\nsz_mf = mapexpect(cs.meanfield.sz, state_mf_t)\n\nsx_mpc = mapexpect(cs.mpc.sx, state_mpc_t)\nsy_mpc = mapexpect(cs.mpc.sy, state_mpc_t)\nsz_mpc = mapexpect(cs.mpc.sz, state_mpc_t)","category":"page"},{"location":"descriptions/#descriptions-quantum","page":"Theoretical Descriptions","title":"Quantum","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"The time evolution of the N spins in a rotating frame corresponding to sum_i omega_0 sigma^z_i is then governed by a master equation","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"dotrho = -fracihbar bigH rhobig + mathcalLrho","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"with the Hamiltonian","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"H = sum_iji neq j hbar Omega_ij sigma_i^+ sigma_j^-","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"and Lindblad-term","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"mathcalLrho = frac12 sum_ij Gamma_ij\n                    (2sigma_i^- rho sigma_j^+\n                    - sigma_i^+ sigma_j^- rho\n                    - rho sigma_i^+ sigma_j^-)","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"The dipole-dipole interaction Omega_ij = frac34 gamma G(k_0 r_ij) and the collective decay Gamma_ij = frac32 gamma F(k_0 r_ij) can be obtained analytically with","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginalign*\nF(xi) = alpha fracsin xixi\n        + beta left(\n              fraccos xixi^2 - fracsin xixi^3\n        right)\n\nG(xi) = -alpha fraccos xixi + beta left(\n            fracsin xixi^2 + fraccos xixi^3\n        right)\nendalign*","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"with alpha = 1 -cos^2 theta and beta = 1-3 cos^2 theta, where theta represents the angle between the line connecting atoms i and j and the common atomic dipole orientation.","category":"page"},{"location":"descriptions/#descriptions-cumulant0","page":"Theoretical Descriptions","title":"0th order: Independent spins","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"Each spin evolves independently according to","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginalign*\nlangledotsigma_k^xrangle  =\n  -frac12 gamma langlesigma_k^xrangle\n\nlangledotsigma_k^yrangle  =\n  -frac12 gamma langlesigma_k^yrangle\n\nlangledotsigma_k^zrangle =\n    gamma big(1 - langlesigma_k^zranglebig)\nendalign*","category":"page"},{"location":"descriptions/#descriptions-cumulant1","page":"Theoretical Descriptions","title":"1st order: Meanfield","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginalign*\nlangledotsigma_k^xrangle  =\n  sum_ii neq k Omega_ki langlesigma_i^ysigma_k^zrangle\n  -frac12 gamma langlesigma_k^xrangle\n  -frac12 sum_ii neq k Gamma_ki langlesigma_i^xsigma_k^zrangle\n\nlangledotsigma_k^yrangle  =\n  -sum_ii neq k Omega_ki langlesigma_i^xsigma_k^zrangle\n  -frac12 gamma langlesigma_k^yrangle\n  -frac12 sum_ii neq k Gamma_ki langlesigma_i^ysigma_k^zrangle\n\nlangledotsigma_k^zrangle =\n    -i sum_ii neq k Omega_ki Big(langlesigma_k^xsigma_i^yrangle - langlesigma_i^xsigma_k^yrangleBig)\n    +gamma big(1 - langlesigma_k^zranglebig)\n    qquad\n    +frac12 sum_ii neq k Gamma_ki Big(langlesigma_k^xsigma_i^xrangle + langlesigma_i^ysigma_k^yrangleBig)\n  endalign*","category":"page"},{"location":"descriptions/#descriptions-cumulant2","page":"Theoretical Descriptions","title":"2nd order: Meanfield plus Correlations (MPC)","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginalign*\nlangledotsigma_k^xsigma_l^xrangle =\n  sum_jj neq kl Omega_kj langlesigma_k^zsigma_l^xsigma_j^yrangle\n   + sum_jj neq kl Omega_lj langlesigma_k^xsigma_l^zsigma_j^yrangle\nqquad\n  - gamma langlesigma_k^xsigma_l^xrangle\n  + Gamma_kl Big(\n          langlesigma_k^zsigma_l^zrangle\n          - frac12 langlesigma_k^zrangle\n          - frac12 langlesigma_l^zrangle\n    Big)\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^xsigma_j^xrangle\n    - frac12 sum_jj neq kl Gamma_lj\n          langlesigma_k^xsigma_l^zsigma_j^xrangle\n\nlangledotsigma_k^ysigma_l^yrangle\n= - sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^ysigma_j^xrangle\n    - sum_jj neq kl Omega_lj\n      langlesigma_k^ysigma_l^zsigma_j^xrangle\nqquad\n    - gamma langlesigma_k^ysigma_l^yrangle\n    + Gamma_klBig(\n          langlesigma_k^zsigma_l^zrangle\n        -frac12 langlesigma_k^zrangle\n        -frac12 langlesigma_l^zrangle\n    Big)\nquad\n    -frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^ysigma_j^yrangle\n    -frac12 sum_jj neq kl Gamma_lj\n          langlesigma_k^ysigma_l^zsigma_j^yrangle\n\nlangledotsigma_k^zsigma_l^zrangle\n= sum_jj neq kl Omega_kj Big(\n      langlesigma_k^ysigma_l^zsigma_j^xrangle\n      - langlesigma_k^xsigma_l^zsigma_j^yrangle\n    Big)\nqquad\n    +sum_jj neq kl Omega_lj Big(\n      langlesigma_k^zsigma_l^ysigma_j^xrangle\n      -langlesigma_k^zsigma_l^xsigma_j^yrangle\n    Big)\nquad\n    - 2 gamma langlesigma_k^zsigma_l^zrangle\n    + gamma big(langlesigma_l^zrangle + langlesigma_k^zranglebig)\nquad\n    +Gamma_klBig(\n          langlesigma_k^ysigma_l^yrangle\n          + langlesigma_k^xsigma_l^xrangle\n    Big)\nquad\n    +frac12 sum_jj neq kl Gamma_kj Big(\n          langlesigma_k^xsigma_l^zsigma_j^xrangle\n          +langlesigma_k^ysigma_l^zsigma_j^yrangle\n    Big)\nqquad\n    +frac12 sum_jj neq kl Gamma_lj Big(\n          langlesigma_k^zsigma_l^xsigma_j^xrangle\n          +langlesigma_k^zsigma_l^ysigma_j^yrangle\n    Big)\nendalign*","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginalign*\nlangledotsigma_k^xsigma_l^yrangle\n= Omega_klBig(\n      langlesigma_k^zrangle\n      - langlesigma_l^zrangle\n    Big)\n    +sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^ysigma_j^yrangle\nqquad\n    -sum_jj neq kl Omega_lj\n      langlesigma_k^xsigma_l^zsigma_j^xrangle\n    - gamma langlesigma_k^xsigma_l^yrangle\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^ysigma_j^xrangle\n    - frac12 sum_jj neq kl Gamma_lj\n          langlesigma_k^xsigma_l^zsigma_j^yrangle\n\nlangledotsigma_k^xsigma_l^zrangle\n= Omega_kl\n      langlesigma_l^yrangle\n    +sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^zsigma_j^yrangle\nquad\n    +sum_jj neq kl Omega_lj Big(\n      langlesigma_k^xsigma_l^ysigma_j^xrangle\n      -langlesigma_k^xsigma_l^xsigma_j^yrangle\n    Big)\nquad\n- frac32 gamma langlesigma_k^xsigma_l^zrangle\n  + gamma langlesigma_k^xrangle\n  - Gamma_klBig(\n        langlesigma_k^zsigma_l^xrangle\n        -frac12 langlesigma_l^xrangle\n    Big)\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^zsigma_j^xrangle\nquad\n    + frac12 sum_jj neq kl Gamma_lj Big(\n          langlesigma_k^xsigma_l^xsigma_j^xrangle\n          +langlesigma_k^xsigma_l^ysigma_j^yrangle\n    Big)\nendalign*","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginalign*\nlangledotsigma_k^ysigma_l^zrangle\n= -Omega_kl langlesigma_l^xrangle\n    -sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^zsigma_j^xrangle\nquad\n    +sum_jj neq kl Omega_lj Big(\n      langlesigma_k^ysigma_l^ysigma_j^xrangle\n      -langlesigma_k^ysigma_l^xsigma_j^yrangle\n    Big)\nquad\n  - frac32 gamma langlesigma_k^ysigma_l^zrangle\n  + gamma langlesigma_k^yrangle\n  - Gamma_klBig(\n          langlesigma_k^zsigma_l^yrangle\n        - frac12langlesigma_l^yrangle\n    Big)\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^zsigma_j^yrangle\nquad\n    + frac12 sum_jj neq kl Gamma_lj Big(\n          langlesigma_k^ysigma_l^xsigma_j^xrangle\n          +langlesigma_k^ysigma_l^ysigma_j^yrangle\n    Big)\nendalign*","category":"page"},{"location":"effective_interaction/#Effective-Interactions","page":"Effective Interactions","title":"Effective Interactions","text":"","category":"section"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"Effective interactions occur in the equations of motion of large spin systems that have certain symmetries so that the dynamics of every single spin is identical:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nlangledotsigma^xrangle =\n  Omega^mathrmefflanglesigma^yranglelanglesigma^zrangle\n  -frac12 Big(\n      gamma\n    -Gamma^mathrmefflanglesigma^zrangle\n  Big) langlesigma^xrangle\n\nlangledotsigma^yrangle =\n  -Omega^mathrmefflanglesigma^xranglelanglesigma^zrangle\n  -frac12 Big(\n    gamma\n    -Gamma^mathrmefflanglesigma^zrangle\n  Big) langlesigma^yrangle\n\nlangledotsigma^zrangle =\n    -gamma big(1 + langlesigma^zranglebig)\n    -frac12 Gamma^mathrmeff Big(langlesigma^xrangle^2 + langlesigma^yrangle^2Big)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"These quantities encapsulate the influence of all spins onto one single spin:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nOmega^mathrmeff = sum_j=2^N Omega_1j\n\nGamma^mathrmeff = sum_j=2^N Gamma_1j\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"The following functions can be used to easily calculate them for common examples:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"CollectiveSpins.effective_interaction.triangle_orthogonal\nCollectiveSpins.effective_interaction.square_orthogonal\nCollectiveSpins.effective_interaction.rectangle_orthogonal\nCollectiveSpins.effective_interaction.cube_orthogonal\nCollectiveSpins.effective_interaction.box_orthogonal\nCollectiveSpins.effective_interaction.chain\nCollectiveSpins.effective_interaction.chain_orthogonal\nCollectiveSpins.effective_interaction.squarelattice_orthogonal\nCollectiveSpins.effective_interaction.hexagonallattice_orthogonal\nCollectiveSpins.effective_interaction.cubiclattice_orthogonal\nCollectiveSpins.effective_interaction.tetragonallattice_orthogonal\nCollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","category":"page"},{"location":"effective_interaction/#Rotated-effective-interactions","page":"Effective Interactions","title":"Rotated effective interactions","text":"","category":"section"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"If we allow for the individual atomic states to bare a spatially dependent phase of Delta phi on the excited state, i.e. psi_krangle = frac1sqrt2 left( grangle + exp (i phi_k) erangle right),  we can absorb this into our equations efficiently. Using the abbreviations Omega_kj^mathrmcos = Omega_kj cos(phi_k - phi_j) and Omega_kj^mathrmsin = Omega_kj sin(phi_k - phi_j) we obtain the following modified equations of motion","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nfracddtlangletildesigma_k^xrangle\n= sum_jj neq k Omega_kj^mathrmsin langletildesigma_j^xsigma_k^zrangle\n        + sum_jj neq k Omega_kj^mathrmcos langletildesigma_j^ysigma_k^zrangle\n    -frac12 gamma langletildesigma_k^xrangle\n    +frac12 sum_jj neq k Gamma_kj^mathrmcos langletildesigma_j^x sigma_k^zrangle\n        -frac12sum_jj neq k Gamma_kj^mathrmsin langletildesigma_j^y sigma_k^zrangle\n\nfracddtlangletildesigma_k^yrangle\n= -sum_jj neq k Omega_kj^mathrmcos langletildesigma_j^xsigma_k^zrangle\n        + sum_jj neq k Omega_kj^mathrmsin langletildesigma_j^ysigma_k^zrangle\n    -frac12 gamma langletildesigma_k^yrangle\n    +frac12 sum_jj neq k Gamma_kj^mathrmsin langletildesigma_j^x sigma_k^zrangle\n    +frac12 sum_jj neq k Gamma_kj^mathrmcos langletildesigma_j^y sigma_k^zrangle\n\nfracddtlanglesigma_k^zrangle\n= -sum_jj neq k Omega_kj^mathrmsin (\n            langletildesigma_j^x tildesigma_k^xrangle\n            + langletildesigma_j^y tildesigma_k^yrangle)\n    +sum_jj neq k Omega_kj^mathrmcos (\n            langletildesigma_j^x tildesigma_k^yrangle\n            - langletildesigma_j^y tildesigma_k^xrangle)\n  qquad\n    -gamma (1+ langlesigma_k^zrangle)\n    -frac12 sum_jj neq k Gamma_kj^mathrmcos (\n            langletildesigma_j^x tildesigma_k^xrangle\n            + langletildesigma_j^y tildesigma_k^yrangle)\n    -frac12 sum_jj neq k Gamma_kj^mathrmsin (\n            langletildesigma_j^x tildesigma_k^yrangle\n            - langletildesigma_j^y tildesigma_k^xrangle)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"We see that the following definitions prove to be very helpful","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nOmega_k^mathrmcos = sum_jj neq k Omega_kj cos(phi_k-phi_j)\nqquad\nOmega_k^mathrmsin = sum_jj neq k Omega_kj sin(phi_k-phi_j)\n\nGamma_k^mathrmcos = sum_jj neq k Gamma_kj cos(phi_k-phi_j)\nqquad\nGamma_k^mathrmsin = sum_jj neq k Gamma_kj sin(phi_k-phi_j)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"Again, if we consider highly symmetric configurations where Omega^mathrmf = Omega^mathrmf_k and Gamma^mathrmf = Gamma^mathrmf_k and the rotated states are initially identical we can define the effective rotated quantities","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\ntildeOmega^mathrmeff = Omega^mathrmcos - frac12 Gamma^mathrmsin\n\ntildeGamma^mathrmeff = Gamma^mathrmcos + 2 Omega^mathrmsin\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"which lead to a closed set of simplified effective equations as well, i.e.","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nfracddtlangletildesigma^xrangle  =\n  tildeOmega^mathrmefflangletildesigma^yranglelanglesigma^zrangle\n  -frac12 gamma langletildesigma^xrangle\n  +frac12 tildeGamma^mathrmeff langletildesigma^xranglelanglesigma^zrangle\n\nfracddtlangletildesigma^yrangle  =\n  -tildeOmega^mathrmefflangletildesigma^xranglelanglesigma^zrangle\n  -frac12 gamma langletildesigma^yrangle\n  +frac12 tildeGamma^mathrmeff langletildesigma^yranglelanglesigma^zrangle\n\nfracddtlanglesigma^zrangle  =\n    -gamma big(1 + langlesigma^zranglebig)\n    -frac12 tildeGamma^mathrmeff Big(langletildesigma^xrangle^2 + langletildesigma^yrangle^2Big)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"The calculation of these quantities for a few systems is implemented by:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"CollectiveSpins.effective_interaction_rotated.square_orthogonal\nCollectiveSpins.effective_interaction_rotated.cube_orthogonal\nCollectiveSpins.effective_interaction_rotated.chain_orthogonal","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CollectiveSpins.jl is a numerical framework that can be used to simulate quantum systems consisting of spatially distributed spins interacting via Dipole-Dipole interaction, optionally coupled to a cavity.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The Geometry module allows the rapid creation of arbitrarily placed spins in order to build up very general systems as explained in the System documentation. These can then be investigated using either a complete quantum description or cumulant expansions up to second order. The details are presented in Theoretical Descriptions.","category":"page"}]
}
